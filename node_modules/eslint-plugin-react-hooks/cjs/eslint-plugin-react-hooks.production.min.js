/** @license React vundefined
 * eslint-plugin-react-hooks.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';function U(a){return"Identifier"===a.type?/^use[A-Z0-9].*$/.test(a.name):"MemberExpression"===a.type&&!a.computed&&U(a.property)?(a=a.object,"Identifier"===a.type&&"React"===a.name):!1}function ba(a){return"Identifier"===a.type?!/^[a-z]/.test(a.name):!1}function ca(a,f){return a.name===f||"MemberExpression"===a.type&&"React"===a.object.name&&a.property.name===f}function da(a){return!!(a.parent&&a.parent.callee&&ca(a.parent.callee,"forwardRef"))}
function ea(a){return!!(a.parent&&a.parent.callee&&ca(a.parent.callee,"memo"))}function fa(a){for(;a;){var f=ha(a);if(f&&(ba(f)||U(f))||da(a)||ea(a))return!0;a=a.parent}return!1}
function ha(a){if("FunctionDeclaration"===a.type||"FunctionExpression"===a.type&&a.id)return a.id;if("FunctionExpression"===a.type||"ArrowFunctionExpression"===a.type)return"VariableDeclarator"===a.parent.type&&a.parent.init===a?a.parent.id:"AssignmentExpression"===a.parent.type&&a.parent.right===a&&"="===a.parent.operator?a.parent.left:"Property"!==a.parent.type||a.parent.value!==a||a.parent.computed?"AssignmentPattern"!==a.parent.type||a.parent.right!==a||a.parent.computed?void 0:a.parent.left:
a.parent.key}
function W(a){function f(){return{isRequired:!1,isSatisfiedRecursively:!1,hasRequiredNodesBelow:!1,children:new Map}}function e(a,d){d=d.split(".");var l=!0,m=!1,e=void 0;try{for(var h=d[Symbol.iterator](),q;!(l=(q=h.next()).done);l=!0){var k=q.value,w=a.children.get(k);w||(w=f(),a.children.set(k,w));a=w}}catch(D){m=!0,e=D}finally{try{l||null==h.return||h.return()}finally{if(m)throw e;}}return a}function h(a,d,f){d=d.split(".");var l=!0,m=!1,e=void 0;try{for(var h=d[Symbol.iterator](),w;!(l=(w=h.next()).done);l=
!0){var k=a.children.get(w.value);if(!k)break;f(k);a=k}}catch(D){m=!0,e=D}finally{try{l||null==h.return||h.return()}finally{if(m)throw e;}}}function d(a,f,m,h){a.children.forEach(function(a,l){var e=h(l);a.isSatisfiedRecursively?a.hasRequiredNodesBelow&&m.add(e):a.isRequired?f.add(e):d(a,f,m,function(a){return e+"."+a})})}var w=a.dependencies,p=a.declaredDependencies,x=a.optionalDependencies,m=a.externalDependencies,E=a.isEffect,F=f();w.forEach(function(a,d){e(F,d).isRequired=!0;h(F,d,function(a){a.hasRequiredNodesBelow=
!0})});p.forEach(function(a){e(F,a.key).isSatisfiedRecursively=!0});x.forEach(function(a){e(F,a).isSatisfiedRecursively=!0});a=new Set;var k=new Set;d(F,a,k,function(a){return a});var r=[],A=new Set,B=new Set;p.forEach(function(a){a=a.key;k.has(a)?-1===r.indexOf(a)?r.push(a):B.add(a):!E||a.endsWith(".current")||m.has(a)?A.add(a):-1===r.indexOf(a)&&r.push(a)});a.forEach(function(a){r.push(a)});return{suggestedDependencies:r,unnecessaryDependencies:A,duplicateDependencies:B,missingDependencies:a}}
function ia(a){var f=a.declaredDependenciesNode,e=a.componentScope,h=a.scope;return a.declaredDependencies.map(function(a){a=e.set.get(a.key);if(null==a)return null;var d=a.defs[0];return null==d?null:"Variable"===d.type&&"VariableDeclarator"===d.node.type&&null!=d.node.init&&("ArrowFunctionExpression"===d.node.init.type||"FunctionExpression"===d.node.init.type)||"FunctionName"===d.type&&"FunctionDeclaration"===d.node.type?a:null}).filter(Boolean).map(function(a){var d=a.defs[0];a:{for(var e=!1,x=
0;x<a.references.length;x++){var m=a.references[x];if(m.writeExpr)if(e){a=!0;break a}else{e=!0;continue}for(var E=m.from;E!==h&&null!=E;)E=E.upper;if(E!==h&&!ja(f,m.identifier)){a=!0;break a}}a=!1}return{fn:d,suggestUseCallback:a}})}function ka(a){return"MemberExpression"!==a.parent.type||a.parent.object!==a||"current"===a.parent.property.name||a.parent.computed||null!=a.parent.parent&&"CallExpression"===a.parent.parent.type&&a.parent.parent.callee===a.parent?a:ka(a.parent)}
function Y(a){if("Identifier"===a.type)return a.name;if("MemberExpression"!==a.type||a.computed)throw Error("Unsupported node type: "+a.type);var f=Y(a.object);a=Y(a.property);return f+"."+a}function ma(a){return"MemberExpression"!==a.type||"Identifier"!==a.object.type||"React"!==a.object.name||"Identifier"!==a.property.type||a.computed?a:a.property}
function na(a,f){var e=ma(a);if("Identifier"!==e.type)return null;switch(e.name){case "useEffect":case "useLayoutEffect":case "useCallback":case "useMemo":return 0;case "useImperativeHandle":return 1;default:if(e===a&&f&&f.additionalHooks){try{var h=Y(e)}catch(d){if(/Unsupported node type/.test(d.message))return 0;throw d;}return f.additionalHooks.test(h)?0:-1}return-1}}
function Z(a,f){for(var e=[a],h=null;e.length;){h=e.shift();if("Identifier"===h.type&&h.name===f.name&&h.range[0]===f.range[0]&&h.range[1]===f.range[1])return h;if(ja(h,f)){a=0;for(var d=Object.entries(h);a<d.length;a++){var w=d[a],p=w[1];"parent"!==w[0]&&(oa(p)?(p.parent=h,e.push(p)):Array.isArray(p)&&p.forEach(function(a){oa(a)&&(a.parent=h,e.push(a))}))}}}return null}
function pa(a){for(var f="",e=0;e<a.length;e++)f+=a[e],0===e&&2===a.length?f+=" and ":e===a.length-2&&2<a.length?f+=", and ":e<a.length-1&&(f+=", ");return f}function oa(a){return"object"===typeof a&&null!==a&&!Array.isArray(a)&&"string"===typeof a.type}function ja(a,f){return a.range[0]<=f.range[0]&&a.range[1]>=f.range[1]}exports.configs={recommended:{plugins:["react-hooks"],rules:{"react-hooks/rules-of-hooks":"error","react-hooks/exhaustive-deps":"warn"}}};
exports.rules={"rules-of-hooks":{create:function(a){var f=[],e=[];return{onCodePathSegmentStart:function(a){return e.push(a)},onCodePathSegmentEnd:function(){return e.pop()},onCodePathStart:function(){return f.push(new Map)},onCodePathEnd:function(e,d){function h(a,g){var b=h.cache,c=b.get(a.id);g=new Set(g);if(g.has(a.id)){b=[].concat(g);a=b.slice(b.indexOf(a.id)+1);b=!0;c=!1;var z=void 0;try{for(var d=a[Symbol.iterator](),f;!(b=(f=d.next()).done);b=!0)E.add(f.value)}catch(J){c=!0,z=J}finally{try{b||
null==d.return||d.return()}finally{if(c)throw z;}}return 0}g.add(a.id);if(void 0!==c)return c;if(e.thrownSegments.includes(a))c=0;else if(0===a.prevSegments.length)c=1;else{c=0;d=!0;f=!1;var m=void 0;try{z=a.prevSegments[Symbol.iterator]();for(var k;!(d=(k=z.next()).done);d=!0)c+=h(k.value,g)}catch(J){f=!0,m=J}finally{try{d||null==z.return||z.return()}finally{if(f)throw m;}}}a.reachable&&0===c?b.delete(a.id):b.set(a.id,c);return c}function p(a,g){var b=p.cache,c=b.get(a.id);g=new Set(g);if(g.has(a.id)){b=
Array.from(g);a=b.slice(b.indexOf(a.id)+1);b=!0;c=!1;var z=void 0;try{for(var d=a[Symbol.iterator](),f;!(b=(f=d.next()).done);b=!0)E.add(f.value)}catch(J){c=!0,z=J}finally{try{b||null==d.return||d.return()}finally{if(c)throw z;}}return 0}g.add(a.id);if(void 0!==c)return c;if(e.thrownSegments.includes(a))c=0;else if(0===a.nextSegments.length)c=1;else{c=0;d=!0;f=!1;var m=void 0;try{z=a.nextSegments[Symbol.iterator]();for(var h;!(d=(h=z.next()).done);d=!0)c+=p(h.value,g)}catch(J){f=!0,m=J}finally{try{d||
null==z.return||z.return()}finally{if(f)throw m;}}}b.set(a.id,c);return c}function x(a){var g=x.cache,b=g.get(a.id);if(null===b)return Infinity;if(void 0!==b)return b;g.set(a.id,null);if(0===a.prevSegments.length)b=1;else{b=Infinity;var c=!0,z=!1,d=void 0;try{for(var f=a.prevSegments[Symbol.iterator](),e;!(c=(e=f.next()).done);c=!0){var m=x(e.value);m<b&&(b=m)}}catch(J){z=!0,d=J}finally{try{c||null==f.return||f.return()}finally{if(z)throw d;}}b+=1}g.set(a.id,b);return b}var m=f.pop();if(0!==m.size){var E=
new Set;h.cache=new Map;p.cache=new Map;x.cache=new Map;var F=p(e.initialSegment),k=ha(d),r=fa(d),A=k?ba(k)||U(k):da(d)||ea(d),B=Infinity,l=!0,q=!1,H=void 0;try{for(var v=e.finalSegments[Symbol.iterator](),L;!(l=(L=v.next()).done);l=!0){var X=L.value;if(X.reachable){var T=x(X);T<B&&(B=T)}}}catch(I){q=!0,H=I}finally{try{l||null==v.return||v.return()}finally{if(q)throw H;}}l=!0;q=!1;H=void 0;try{for(var y=m[Symbol.iterator](),Q;!(l=(Q=y.next()).done);l=!0){var D=Q.value,C=D[0],M=D[1];if(C.reachable){var K=
0===C.nextSegments.length?B<=x(C):B<x(C),R=h(C)*p(C),G=E.has(C.id);m=!0;v=!1;L=void 0;try{for(var u=M[Symbol.iterator](),N;!(m=(N=u.next()).done);m=!0){var n=N.value;G&&a.report({node:n,message:'React Hook "'+a.getSource(n)+'" may be executed more than once. Possibly because it is called in a loop. React Hooks must be called in the exact same order in every component render.'});if(A){if(!G&&R!==F){var V='React Hook "'+a.getSource(n)+'" is called conditionally. React Hooks must be called in the exact same order in every component render.'+
(K?" Did you accidentally call a React Hook after an early return?":"");a.report({node:n,message:V})}}else if(d.parent&&("MethodDefinition"===d.parent.type||"ClassProperty"===d.parent.type)&&d.parent.value===d){var O='React Hook "'+a.getSource(n)+'" cannot be called in a class component. React Hooks must be called in a React function component or a custom React Hook function.';a.report({node:n,message:O})}else if(k){var S='React Hook "'+a.getSource(n)+'" is called in function "'+(a.getSource(k)+'" that is neither a React function component nor a custom React Hook function.');
a.report({node:n,message:S})}else if("Program"===d.type){var t='React Hook "'+a.getSource(n)+'" cannot be called at the top level. React Hooks must be called in a React function component or a custom React Hook function.';a.report({node:n,message:t})}else if(r){var P='React Hook "'+a.getSource(n)+'" cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function.';a.report({node:n,message:P})}}}catch(I){v=!0,L=I}finally{try{m||null==u.return||
u.return()}finally{if(v)throw L;}}}}}catch(I){q=!0,H=I}finally{try{l||null==y.return||y.return()}finally{if(q)throw H;}}}},CallExpression:function(a){if(U(a.callee)){var d=f[f.length-1],h=e[e.length-1],p=d.get(h);p||(p=[],d.set(h,p));p.push(a.callee)}}}}},"exhaustive-deps":{meta:{schema:[{type:"object",additionalProperties:!1,properties:{additionalHooks:{type:"string"}}}]},create:function(a){function f(a,d){return function(f){if(d.has(f))return d.get(f);var e=a(f);d.set(f,e);return e}}function e(e){function m(a){var b=
!0,c=!1,g=void 0;try{for(var d=a.references[Symbol.iterator](),f;!(b=(f=d.next()).done);b=!0){var h=f.value;if(h.resolved&&H.has(h.resolved.scope)){var k=Z(e,h.identifier),l=ka(k),p=Y(l),q;if(q=B&&"Identifier"===l.type&&"MemberExpression"===l.parent.type&&!l.parent.computed&&"Identifier"===l.parent.property.type&&"current"===l.parent.property.name){for(var n=h.from,t=!1;n.block!==e;)"function"===n.type&&(t=null!=n.block.parent&&"ReturnStatement"===n.block.parent.type),n=n.upper;q=t}q&&T.set(p,{reference:h,
dependencyNode:l});var r=h.resolved.defs[0];if(null!=r&&(null==r.node||r.node.init!==e.parent)&&"TypeParameter"!==r.type)if(y.has(p))y.get(p).references.push(h);else{var v=h.resolved,w=L(v)||X(v);y.set(p,{isStatic:w,references:[h]})}}}}catch(aa){c=!0,g=aa}finally{try{b||null==d.return||d.return()}finally{if(c)throw g;}}b=!0;c=!1;g=void 0;try{for(var u=a.childScopes[Symbol.iterator](),x;!(b=(x=u.next()).done);b=!0)m(x.value)}catch(aa){c=!0,g=aa}finally{try{b||null==u.return||u.return()}finally{if(c)throw g;
}}}function F(a,b,c,d){return 0===a.size?null:(1<a.size?"":b+" ")+c+" "+(1<a.size?"dependencies":"dependency")+": "+pa(Array.from(a).sort().map(function(a){return"'"+a+"'"}))+(". Either "+d+" "+(1<a.size?"them":"it")+" or remove the dependency array.")}if(("FunctionExpression"===e.type||"ArrowFunctionExpression"===e.type)&&"CallExpression"===e.parent.type){var k=na(e.parent.callee,h);if(e.parent.arguments[k]===e){var r=e.parent.callee,A=ma(r).name,B=/Effect($|[^a-z])/g.test(A),l=e.parent.arguments[k+
1];if(l||B){B&&e.async&&a.report({node:e,message:"Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching"});var q=a.getScope(),H=new Set,v=null;for(k=q.upper;k;){H.add(k);
if("function"===k.type)break;k=k.upper}if(k){v=k;var L=f(function(a){if(!Array.isArray(a.defs))return!1;var b=a.defs[0];if(null==b||"VariableDeclarator"!==b.node.type)return!1;var c=b.node.init;if(null==c)return!1;var g=b.node.parent;if(null==g&&(Z(v.block,b.node.id),g=b.node.parent,null==g))return!1;if("const"===g.kind&&"Literal"===c.type&&("string"===typeof c.value||"number"===typeof c.value||null===c.value))return!0;if("CallExpression"!==c.type)return!1;c=c.callee;"MemberExpression"!==c.type||
"React"!==c.object.name||null==c.property||c.computed||(c=c.property);if("Identifier"!==c.type)return!1;b=b.node.id;c=c.name;if("useRef"===c&&"Identifier"===b.type)return!0;if(("useState"===c||"useReducer"===c)&&"ArrayPattern"===b.type&&2===b.elements.length&&Array.isArray(a.identifiers)){if(b.elements[1]===a.identifiers[0]){if("useState"===c)for(a=a.references,c=0;c<a.length;c++)d.set(a[c].identifier,b.elements[0]);return!0}if(b.elements[0]===a.identifiers[0]&&"useState"===c)for(a=a.references,b=
0;b<a.length;b++)w.add(a[b].identifier)}return!1},p),X=f(function(a){if(!Array.isArray(a.defs))return!1;a=a.defs[0];if(null==a||null==a.node||null==a.node.id)return!1;var b=a.node,c=v.childScopes;a=null;var g;for(g=0;g<c.length;g++){var d=c[g],e=d.block;if("FunctionDeclaration"===b.type&&e===b||"VariableDeclarator"===b.type&&e.parent===b){a=d;break}}if(null==a)return!1;for(g=0;g<a.through.length;g++)if(b=a.through[g],null!=b.resolved&&H.has(b.resolved.scope)&&!L(b.resolved))return!1;return!0},x),
T=new Map,y=new Map;m(q);T.forEach(function(g,b){var c=g.dependencyNode;g=g.reference.resolved.references;for(var d=!1,e=0;e<g.length;e++){var f=g[e].identifier.parent;if(null!=f&&"MemberExpression"===f.type&&!f.computed&&"Identifier"===f.property.type&&"current"===f.property.name&&"AssignmentExpression"===f.parent.type&&f.parent.left===f){d=!0;break}}d||a.report({node:c.parent.property,message:"The ref value '"+b+".current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy '"+
(b+".current' to a variable inside the effect, and use that variable in the cleanup function.")})});var Q=new Set,D=new Set;y.forEach(function(g,b){var c=g.references;g.isStatic&&D.add(b);c.forEach(function(c){c.writeExpr&&(c=c.writeExpr,Q.has(b)||(Q.add(b),a.report({node:c,message:"Assignments to the '"+b+"' variable from inside React Hook "+(a.getSource(r)+" will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside ")+
(a.getSource(r)+".")})))})});if(!(0<Q.size))if(l){var C=[],M=new Set;"ArrayExpression"!==l.type?a.report({node:l,message:"React Hook "+a.getSource(r)+" was passed a dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies."}):l.elements.forEach(function(g){if(null!==g)if("SpreadElement"===g.type)a.report({node:g,message:"React Hook "+a.getSource(r)+" has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies."});
else{try{var b=Y(g)}catch(la){if(/Unsupported node type/.test(la.message)){"Literal"===g.type?y.has(g.value)?a.report({node:g,message:"The "+g.raw+" literal is not a valid dependency because it never changes. Did you mean to include "+(g.value+" in the array instead?")}):a.report({node:g,message:"The "+g.raw+" literal is not a valid dependency because it never changes. You can safely remove it."}):a.report({node:g,message:"React Hook "+a.getSource(r)+" has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked."});
return}throw la;}for(var c=g;"MemberExpression"===c.type;)c=c.object;var d=!v.through.some(function(a){return a.identifier===c});C.push({key:b,node:g});d||M.add(b)}});var K=W({dependencies:y,declaredDependencies:C,optionalDependencies:D,externalDependencies:M,isEffect:B}),R=K.suggestedDependencies;k=K.unnecessaryDependencies;var G=K.missingDependencies;K=K.duplicateDependencies;if(0===K.size+G.size+k.size)ia({declaredDependencies:C,declaredDependenciesNode:l,componentScope:v,scope:q}).forEach(function(g){var b=
g.fn;g=g.suggestUseCallback;var c="The '"+b.name.name+"' function makes the dependencies of "+(A+" Hook (at line "+l.loc.start.line+") change on every render.");c=g?c+(" To fix this, wrap the '"+(b.name.name+"' definition into its own useCallback() Hook.")):c+(" Move it inside the "+A+" callback. Alternatively, wrap the '"+(b.name.name+"' definition into its own useCallback() Hook."));var d;g&&"Variable"===b.type&&(d=[{desc:"Wrap the '"+b.name.name+"' definition into its own useCallback() Hook.",
fix:function(a){return[a.insertTextBefore(b.node.init,"useCallback("),a.insertTextAfter(b.node.init,")")]}}]);a.report({node:b.node,message:c,suggest:d})});else{!B&&0<G.size&&(R=W({dependencies:y,declaredDependencies:[],optionalDependencies:D,externalDependencies:M,isEffect:B}).suggestedDependencies);(function(){if(0===C.length)return!0;var a=C.map(function(a){return a.key}),b=a.slice().sort();return a.join(",")===b.join(",")})()&&R.sort();var u="";if(0<k.size){var N=null;Array.from(k.keys()).forEach(function(a){null===
N&&a.endsWith(".current")&&(N=a)});if(null!==N)u=" Mutable values like '"+N+"' aren't valid dependencies because mutating them doesn't re-render the component.";else if(0<M.size){var n=Array.from(M)[0];q.set.has(n)||(u=" Outer scope values like '"+n+"' aren't valid dependencies because mutating them doesn't re-render the component.")}}if(!u&&G.has("props")){q=y.get("props");if(null==q)return;q=q.references;if(!Array.isArray(q))return;n=!0;for(var V=0;V<q.length;V++){var O=Z(v.block,q[V].identifier);
if(!O){n=!1;break}O=O.parent;if(null==O){n=!1;break}if("MemberExpression"!==O.type){n=!1;break}}n&&(u=" However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the "+(A+" call and refer to those specific props inside ")+(a.getSource(r)+"."))}if(!u&&0<G.size){var S=null;G.forEach(function(a){if(!S){var b=v.set.get(a),c=y.get(a);if(c.references[0].resolved===b&&(b=b.defs[0],null!=b&&null!=b.name&&"Parameter"===b.type)){b=!1;for(var d,
e=0;e<c.references.length;e++)if(d=c.references[e].identifier,null!=d&&null!=d.parent&&"CallExpression"===d.parent.type&&d.parent.callee===d){b=!0;break}b&&(S=a)}}});null!==S&&(u=" If '"+S+"' changes too often, find the parent component that defines it and wrap that definition in useCallback.")}if(!u&&0<G.size){var t=null;G.forEach(function(a){if(null===t)for(var b=y.get(a).references,c,e,f=0;f<b.length;f++){c=b[f].identifier;for(e=c.parent;null!=e&&e!==v.block;){if("CallExpression"===e.type){var g=
d.get(e.callee);if(null!=g){g.name===a?t={missingDep:a,setter:e.callee.name,form:"updater"}:w.has(c)?t={missingDep:a,setter:e.callee.name,form:"reducer"}:(c=b[f].resolved,null!=c&&(c=c.defs[0],null!=c&&"Parameter"===c.type&&(t={missingDep:a,setter:e.callee.name,form:"inlineReducer"})));break}}e=e.parent}if(null!==t)break}});if(null!==t)switch(t.form){case "reducer":u=" You can also replace multiple useState variables with useReducer if '"+(t.setter+"' needs the current value of '")+(t.missingDep+
"'.");break;case "inlineReducer":u=" If '"+t.setter+"' needs the current value of '"+(t.missingDep+"', you can also switch to useReducer instead of useState and read '")+(t.missingDep+"' in the reducer.");break;case "updater":u=" You can also do a functional update '"+t.setter+"("+t.missingDep.substring(0,1)+" => ...)' if you only need '"+t.missingDep+"' in the '"+(t.setter+"' call.");break;default:throw Error("Unknown case.");}}a.report({node:l,message:"React Hook "+a.getSource(r)+" has "+(F(G,"a",
"missing","include")||F(k,"an","unnecessary","exclude")||F(K,"a","duplicate","omit"))+u,suggest:[{desc:"Update the dependencies array to be: ["+R.join(", ")+"]",fix:function(a){return a.replaceText(l,"["+R.join(", ")+"]")}}]})}}else{var P=null;y.forEach(function(a,b){P||a.references.forEach(function(a){if(!P&&d.has(a.identifier)){for(a=a.from;"function"!==a.type;)a=a.upper;a.block===e&&(P=b)}})});if(P){var I=W({dependencies:y,declaredDependencies:[],optionalDependencies:D,externalDependencies:new Set,
isEffect:!0}).suggestedDependencies;a.report({node:e.parent.callee,message:"React Hook "+A+" contains a call to '"+P+"'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass ["+I.join(", ")+("] as a second argument to the "+A+" Hook."),suggest:[{desc:"Add dependencies array: ["+I.join(", ")+"]",fix:function(a){return a.insertTextAfter(e,", ["+I.join(", ")+"]")}}]})}}}}else"useMemo"!==A&&"useCallback"!==A||a.report({node:e.parent.callee,message:"React Hook "+
A+" does nothing when called with only one argument. Did you forget to pass an array of dependencies?"})}}}var h={additionalHooks:a.options&&a.options[0]&&a.options[0].additionalHooks?new RegExp(a.options[0].additionalHooks):void 0},d=new WeakMap,w=new WeakSet,p=new WeakMap,x=new WeakMap;return{FunctionExpression:e,ArrowFunctionExpression:e}}}};
