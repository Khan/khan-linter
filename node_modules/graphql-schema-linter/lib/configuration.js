'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Configuration = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cosmiconfig = require('cosmiconfig');

var _cosmiconfig2 = _interopRequireDefault(_cosmiconfig);

var _fs = require('fs');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _glob = require('glob');

var _source_map = require('./source_map.js');

var _json_formatter = require('./formatters/json_formatter.js');

var _json_formatter2 = _interopRequireDefault(_json_formatter);

var _text_formatter = require('./formatters/text_formatter.js');

var _text_formatter2 = _interopRequireDefault(_text_formatter);

var _compact_formatter = require('./formatters/compact_formatter.js');

var _compact_formatter2 = _interopRequireDefault(_compact_formatter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Configuration = exports.Configuration = function () {
  /*
    options:
      - configDirectory: path to begin searching for config files
      - format: (required) `text` | `json`
      - rules: [string array] whitelist rules
      - schemaPaths: [string array] file(s) to read schema from
      - customRulePaths: [string array] path to additional custom rules to be loaded
      - stdin: [boolean] pass schema via stdin?
      - commentDescriptions: [boolean] use old way of defining descriptions in GraphQL SDL
      - oldImplementsSyntax: [boolean] use old way of defining implemented interfaces in GraphQL SDL
  */
  function Configuration() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var stdinFd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, Configuration);

    var defaultOptions = {
      format: 'text',
      customRulePaths: [],
      commentDescriptions: false,
      oldImplementsSyntax: false
    };
    var configOptions = loadOptionsFromConfig(options.configDirectory);

    // TODO Get configs from .graphqlconfig file

    this.options = Object.assign({}, defaultOptions, configOptions, options);
    this.stdinFd = stdinFd;
    this.schema = null;
    this.sourceMap = null;
    this.rules = null;
    this.builtInRulePaths = _path2.default.join(__dirname, 'rules/*.js');
    this.rulePaths = this.options.customRulePaths.concat(this.builtInRulePaths);
  }

  _createClass(Configuration, [{
    key: 'getCommentDescriptions',
    value: function getCommentDescriptions() {
      return this.options.commentDescriptions;
    }
  }, {
    key: 'getOldImplementsSyntax',
    value: function getOldImplementsSyntax() {
      return this.options.oldImplementsSyntax;
    }
  }, {
    key: 'getSchema',
    value: function getSchema() {
      if (this.schema) {
        return this.schema;
      }

      if (this.options.stdin) {
        this.schema = getSchemaFromFileDescriptor(this.stdinFd);
        if (this.schema == null) {
          return null;
        }

        this.sourceMap = new _source_map.SourceMap({ stdin: this.schema });
      } else if (this.options.schemaPaths) {
        var schemaPaths = this.options.schemaPaths;

        var expandedPaths = expandPaths(schemaPaths);
        var segments = getSchemaSegmentsFromFiles(expandedPaths);

        if (Object.keys(segments).length === 0) {
          return null;
        }
        this.sourceMap = new _source_map.SourceMap(segments);
        this.schema = this.sourceMap.getCombinedSource();
      }

      return this.schema;
    }
  }, {
    key: 'getSchemaSourceMap',
    value: function getSchemaSourceMap() {
      if (!this.sourceMap) {
        this.getSchema();
      }

      return this.sourceMap;
    }
  }, {
    key: 'getFormatter',
    value: function getFormatter() {
      switch (this.options.format) {
        case 'json':
          return _json_formatter2.default;
        case 'text':
          return _text_formatter2.default;
        case 'compact':
          return _compact_formatter2.default;
      }
    }
  }, {
    key: 'getRules',
    value: function getRules() {
      var rules = this.getAllRules();
      var specifiedRules = void 0;
      if (this.options.rules && this.options.rules.length > 0) {
        specifiedRules = this.options.rules.map(toUpperCamelCase);
        rules = this.getAllRules().filter(function (rule) {
          return specifiedRules.indexOf(rule.name) >= 0;
        });
      }

      // DEPRECATED - This code should be removed in v1.0.0.
      if (this.options.only && this.options.only.length > 0) {
        specifiedRules = this.options.only.map(toUpperCamelCase);
        rules = this.getAllRules().filter(function (rule) {
          return specifiedRules.indexOf(rule.name) >= 0;
        });
      }

      // DEPRECATED - This code should be removed in v1.0.0.
      if (this.options.except && this.options.except.length > 0) {
        specifiedRules = this.options.except.map(toUpperCamelCase);
        rules = this.getAllRules().filter(function (rule) {
          return specifiedRules.indexOf(rule.name) == -1;
        });
      }

      return rules;
    }
  }, {
    key: 'getAllRules',
    value: function getAllRules() {
      if (this.rules !== null) {
        return this.rules;
      }

      this.rules = this.getRulesFromPaths(this.rulePaths);

      return this.rules;
    }
  }, {
    key: 'getRulesFromPaths',
    value: function getRulesFromPaths(rulePaths) {
      var expandedPaths = expandPaths(rulePaths);
      var rules = new Set([]);

      expandedPaths.map(function (rulePath) {
        var ruleMap = require(rulePath);
        Object.keys(ruleMap).forEach(function (k) {
          return rules.add(ruleMap[k]);
        });
      });

      return Array.from(rules);
    }
  }, {
    key: 'getAllBuiltInRules',
    value: function getAllBuiltInRules() {
      return this.getRulesFromPaths([this.builtInRulePaths]);
    }
  }, {
    key: 'validate',
    value: function validate() {
      var issues = [];

      var rules = void 0;

      try {
        rules = this.getAllRules();
      } catch (e) {
        if (e.code === 'MODULE_NOT_FOUND') {
          issues.push({
            message: 'There was an issue loading the specified custom rules: \'' + e.message.split('\n')[0] + '\'',
            field: 'custom-rule-paths',
            type: 'error'
          });

          rules = this.getAllBuiltInRules();
        } else {
          throw e;
        }
      }

      var ruleNames = rules.map(function (rule) {
        return rule.name;
      });

      var misConfiguredRuleNames = [].concat(this.options.only || [], this.options.except || [], this.options.rules || []).map(toUpperCamelCase).filter(function (name) {
        return ruleNames.indexOf(name) == -1;
      });

      if (this.getFormatter() == null) {
        issues.push({
          message: 'The output format \'' + this.options.format + '\' is invalid',
          field: 'format',
          type: 'error'
        });
      }

      if (misConfiguredRuleNames.length > 0) {
        issues.push({
          message: 'The following rule(s) are invalid: ' + misConfiguredRuleNames.join(', '),
          field: 'rules',
          type: 'warning'
        });
      }

      return issues;
    }
  }]);

  return Configuration;
}();

function loadOptionsFromConfig(configDirectory) {
  var searchPath = configDirectory || './';

  var cosmic = (0, _cosmiconfig2.default)('graphql-schema-linter', {
    cache: false
  }).searchSync(searchPath);

  if (cosmic) {
    var schemaPaths = [];
    var customRulePaths = [];

    // If schemaPaths come from cosmic, we resolve the given paths relative to the searchPath.

    if (cosmic.config.schemaPaths) {
      schemaPaths = cosmic.config.schemaPaths.map(function (schemaPath) {
        return _path2.default.resolve(searchPath, schemaPath);
      });
    }

    // If customRulePaths come from cosmic, we resolve the given paths relative to the searchPath.
    if (cosmic.config.customRulePaths) {
      customRulePaths = cosmic.config.customRulePaths.map(function (schemaPath) {
        return _path2.default.resolve(searchPath, schemaPath);
      });
    }

    return {
      rules: cosmic.config.rules,
      customRulePaths: customRulePaths || [],
      schemaPaths: schemaPaths
    };
  } else {
    return {};
  }
}

function getSchemaFromFileDescriptor(fd) {
  var b = new Buffer(1024);
  var data = '';

  while (true) {
    var n = void 0;
    try {
      n = (0, _fs.readSync)(fd, b, 0, b.length);
    } catch (e) {
      if (e.code == 'EAGAIN') {
        console.error('The --stdin option was specified, but not schema was provided via stdin.');
      } else {
        console.error(e.message);
      }
      return null;
    }

    if (!n) {
      break;
    }
    data += b.toString('utf8', 0, n);
  }

  return data;
}

function getSchemaFromFile(path) {
  try {
    return (0, _fs.readFileSync)(path).toString('utf8');
  } catch (e) {
    console.error(e.message);
  }
  return null;
}

function getSchemaSegmentsFromFiles(paths) {
  return paths.reduce(function (segments, path) {
    var schema = getSchemaFromFile(path);
    if (schema) {
      segments[path] = schema;
    }
    return segments;
  }, {});
}

function expandPaths(pathOrPattern) {
  return pathOrPattern.map(function (path) {
    if ((0, _glob.hasMagic)(path)) {
      return (0, _glob.sync)(path);
    } else {
      return path;
    }
  }).reduce(function (a, b) {
    return a.concat(b);
  }, [])
  // Resolve paths to absolute paths so that including the same file
  // multiple times is not treated as different files
  .map(function (p) {
    return _path2.default.resolve(p);
  });
}

function toUpperCamelCase(string) {
  return string.split('-').map(function (part) {
    return part[0].toUpperCase() + part.slice(1);
  }).join('');
}