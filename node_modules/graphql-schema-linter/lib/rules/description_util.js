'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fullDescription = fullDescription;
exports.blankLineBeforeNode = blankLineBeforeNode;
exports.descriptionIsOneLine = descriptionIsOneLine;
exports.leadingQuotesAreTripleQuote = leadingQuotesAreTripleQuote;
exports.leadingQuotesOnTheirOwnLine = leadingQuotesOnTheirOwnLine;
exports.trailingQuotesOnTheirOwnLine = trailingQuotesOnTheirOwnLine;
function fullDescription(node) {
  // While the sdl parser exposes node.description, it sadly elides
  // leading and trailing newlines.  So I look at the source to get
  // my own version (which includes leading and trailing quotes).
  // This is hacky!
  // TODO(csilvers): figure out what source.locationOffset is.
  for (var token = node.loc.startToken; token != node.loc.endToken; token = token.next) {
    if (token.kind === 'BlockString') {
      return node.loc.source.body.substring(token.start, token.end);
    }
  }
  return '';
}

// True if the given node has a blank line before it, or a line
// ending in `{`.  This calculation ignores comment lines.
function blankLineBeforeNode(node) {
  var prevToken = node.loc.startToken.prev;
  while (prevToken && prevToken.kind === 'Comment') {
    prevToken = prevToken.prev;
  }
  return !prevToken || prevToken.kind === '<SOF>' || // "Start of file"
  prevToken.line < prevToken.next.line - 1 || prevToken.kind === '{';
}

function descriptionIsOneLine(description) {
  return description.indexOf('\n') === -1;
}

function leadingQuotesAreTripleQuote(descriptionWithQuotes) {
  return !!descriptionWithQuotes.match(/^"""/);
}

function leadingQuotesOnTheirOwnLine(descriptionWithQuotes) {
  return !!descriptionWithQuotes.match(/^"""\n/);
}

function trailingQuotesOnTheirOwnLine(descriptionWithQuotes) {
  return !!descriptionWithQuotes.match(/\n\s*"""$/);
}