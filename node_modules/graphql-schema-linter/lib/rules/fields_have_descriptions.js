'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FieldsHaveDescriptions = FieldsHaveDescriptions;

var _buildASTSchema = require('graphql/utilities/buildASTSchema');

var _validation_error = require('../validation_error');

var _description_util = require('./description_util.js');

function offsetsOfBlankLinesInDescription(descriptionWithQuotes) {
  var retval = [];
  var blankLineRegexp = new RegExp('\\n\\s*\\n', 'g');
  var m = void 0;
  while (m = blankLineRegexp.exec(descriptionWithQuotes)) {
    // We map to index + 1 to indicate where the blank line begins
    // (not the newline before it).
    retval.push(m.index + 1);
  }
  return retval;
}

// Find the interface type with the given name.  There's probably
// a graphql-js API to do this, but I can't figure it out, so
// I just manually iterate through ancestors.
function findInterface(ancestors, name) {
  for (var i = 0; i < ancestors.length; i++) {
    // Each element of ancestors can be a node or an array of its own.
    if (ancestors[i].length) {
      var found = findInterface(ancestors[i], name);
      if (found) {
        return found;
      }
    } else if (ancestors[i].kind === 'InterfaceTypeDefinition' && ancestors[i].name.value === name) {
      return ancestors[i];
    }
  }
  return null;
}

// Finds all fields defined in any interfaces inherited by
// the type that defines `node`.  `node` should be a FieldDefinition.
function interfaceFieldsFor(node, ancestors) {
  var retval = {};
  var type = ancestors[ancestors.length - 1];
  // For each interface listed on this type, we find the definition
  // of that interface, then add all its fields to retval.
  (type.interfaces || []).forEach(function (i) {
    return findInterface(ancestors, i.name.value).fields.forEach(function (f) {
      return retval[f.name.value] = 1;
    });
  });
  return retval;
}

function reportError(error, context, node, ancestors, offset) {
  var fieldName = node.name.value;
  var parentName = ancestors[ancestors.length - 1].name.value;

  context.reportError(new _validation_error.ValidationError('fields-have-descriptions', 'The field `' + parentName + '.' + fieldName + '`s description ' + error + '.', [node], (0, _description_util.offsetLocation)(node, offset)));
}

function FieldsHaveDescriptions(configuration, context) {
  return {
    FieldDefinition: function FieldDefinition(node, key, parent, path, ancestors) {
      var description = (0, _buildASTSchema.getDescription)(node, {
        commentDescriptions: configuration.getCommentDescriptions()
      });

      if (!description) {
        var fieldName = node.name.value;

        // We do not require descriptions on deprecated fields.
        if (node.directives && node.directives.some(function (d) {
          return d.name.value == 'deprecated';
        })) {
          return;
        }
        // Or on interface fields.
        if (!description && interfaceFieldsFor(node, ancestors)[fieldName]) {
          return;
        }

        return reportError('is missing', context, node, ancestors);
      }

      var descriptionWithQuotes = (0, _description_util.fullDescription)(node);

      if (!(0, _description_util.blankLineBeforeNode)(node)) {
        reportError('should have a blank line before it', context, node, ancestors);
      }

      if (!(0, _description_util.leadingQuotesAreTripleQuote)(descriptionWithQuotes)) {
        if (descriptionWithQuotes[0] === '"') {
          // offset == 0 matches the open single-quote.
          reportError('should use triple-quotes', context, node, ancestors, 0);
          // If the open-quote is a single quote, the end-quote must
          // be too.  We report both for the benefit of auto-fixing.
          reportError('should use triple-quotes', context, node, ancestors, -1);
        } else {
          // offset == 0 matches the `#`.
          reportError('should use triple-quotes', context, node, ancestors, 0);
        }
      }

      offsetsOfBlankLinesInDescription(descriptionWithQuotes).forEach(function (offset) {
        return reportError('should not include a blank line', context, node, ancestors, offset);
      });

      if ((0, _description_util.leadingQuotesOnTheirOwnLine)(descriptionWithQuotes)) {
        // Offset of 0 here matches the triple-quote location.
        reportError('should not put the leading triple-quote on its own line', context, node, ancestors, 0);
      }

      if ((0, _description_util.descriptionIsOneLine)(description) && (0, _description_util.trailingQuotesOnTheirOwnLine)(descriptionWithQuotes)) {
        // Offset of -3 matches the triple-quote location.
        reportError('should not put the trailing triple-quote on its own line', context, node, ancestors, -3);
      }
      if (!(0, _description_util.descriptionIsOneLine)(description) && !(0, _description_util.trailingQuotesOnTheirOwnLine)(descriptionWithQuotes)) {
        // Offset of -3 matches the triple-quote location.
        reportError('should put the trailing triple-quote on its own line', context, node, ancestors, -3);
      }
    }
  };
}