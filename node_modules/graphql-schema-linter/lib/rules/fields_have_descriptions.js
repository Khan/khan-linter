'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FieldsHaveDescriptions = FieldsHaveDescriptions;

var _buildASTSchema = require('graphql/utilities/buildASTSchema');

var _validation_error = require('../validation_error');

var _description_util = require('./description_util.js');

function descriptionHasBlankLine(description) {
  return description.match(/\n\s*\n/);
}

// Find the interface type with the given name.  There's probably
// a graphql-js API to do this, but I can't figure it out, so
// I just manually iterate through ancestors.
function findInterface(ancestors, name) {
  for (var i = 0; i < ancestors.length; i++) {
    // Each element of ancestors can be a node or an array of its own.
    if (ancestors[i].length) {
      var found = findInterface(ancestors[i], name);
      if (found) {
        return found;
      }
    } else if (ancestors[i].kind === 'InterfaceTypeDefinition' && ancestors[i].name.value === name) {
      return ancestors[i];
    }
  }
  return null;
}

// Finds all fields defined in any interfaces inherited by
// the type that defines `node`.  `node` should be a FieldDefinition.
function interfaceFieldsFor(node, ancestors) {
  var retval = {};
  var type = ancestors[ancestors.length - 1];
  // For each interface listed on this type, we find the definition
  // of that interface, then add all its fields to retval.
  type.interfaces.forEach(function (i) {
    return findInterface(ancestors, i.name.value).fields.forEach(function (f) {
      return retval[f.name.value] = 1;
    });
  });
  return retval;
}

function reportError(error, context, node, ancestors) {
  var fieldName = node.name.value;
  var parentName = ancestors[ancestors.length - 1].name.value;

  context.reportError(new _validation_error.ValidationError('fields-have-descriptions', 'The field `' + parentName + '.' + fieldName + '`s description ' + error + '.', [node]));
}

function FieldsHaveDescriptions(configuration, context) {
  return {
    FieldDefinition: function FieldDefinition(node, key, parent, path, ancestors) {
      var description = (0, _buildASTSchema.getDescription)(node, {
        commentDescriptions: configuration.getCommentDescriptions()
      });

      if (!description) {
        var fieldName = node.name.value;

        // We do not require descriptions on deprecated fields.
        if (node.directives && node.directives.some(function (d) {
          return d.name.value == 'deprecated';
        })) {
          return;
        }
        // Or on interface fields.
        if (!description && interfaceFieldsFor(node, ancestors)[fieldName]) {
          return;
        }

        return reportError('is missing', context, node, ancestors);
      }

      var descriptionWithQuotes = (0, _description_util.fullDescription)(node);

      if (!(0, _description_util.blankLineBeforeNode)(node)) {
        reportError('should have a blank line before it', context, node, ancestors);
      }

      if (!(0, _description_util.leadingQuotesAreTripleQuote)(descriptionWithQuotes)) {
        reportError('should use triple-quotes', context, node, ancestors);
      }

      if (descriptionHasBlankLine(description)) {
        reportError('should not include a blank line', context, node, ancestors);
      }

      if ((0, _description_util.leadingQuotesOnTheirOwnLine)(descriptionWithQuotes)) {
        reportError('should not put the leading triple-quote on its own line', context, node, ancestors);
      }

      if ((0, _description_util.descriptionIsOneLine)(description) && (0, _description_util.trailingQuotesOnTheirOwnLine)(descriptionWithQuotes)) {
        reportError('should not put the trailing triple-quote on its own line', context, node, ancestors);
      }
      if (!(0, _description_util.descriptionIsOneLine)(description) && !(0, _description_util.trailingQuotesOnTheirOwnLine)(descriptionWithQuotes)) {
        reportError('should put the trailing triple-quote on its own line', context, node, ancestors);
      }
    }
  };
}