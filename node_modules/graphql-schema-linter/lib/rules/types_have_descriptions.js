'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TypesHaveDescriptions = TypesHaveDescriptions;

var _buildASTSchema = require('graphql/utilities/buildASTSchema');

var _validation_error = require('../validation_error');

var _description_util = require('./description_util.js');

function descriptionHasValidFirstline(description) {
  return description.match(/^[^\n]+(\n\n|$)/);
}

function reportError(error, context, node, typeKind, offset) {
  var interfaceTypeName = node.name.value;

  context.reportError(new _validation_error.ValidationError('types-have-descriptions', 'The ' + typeKind + ' type `' + interfaceTypeName + '`s description ' + error + '.', [node], (0, _description_util.offsetLocation)(node, offset)));
}

function validateTypeHasDescription(configuration, context, node, typeKind) {
  var description = (0, _buildASTSchema.getDescription)(node, {
    commentDescriptions: configuration.getCommentDescriptions()
  });

  if (!description) {
    return reportError('is missing', context, node, typeKind);
  }

  var descriptionWithQuotes = (0, _description_util.fullDescription)(node);

  if (!(0, _description_util.blankLineBeforeNode)(node)) {
    reportError('should have a blank line before it', context, node, typeKind);
  }

  if (!descriptionHasValidFirstline(description)) {
    reportError('should have a one-line firstline, then optionally a blank line followed by other text', context, node, typeKind);
  }

  if (!(0, _description_util.leadingQuotesAreTripleQuote)(descriptionWithQuotes)) {
    if (descriptionWithQuotes[0] === '"') {
      // offset == 0 matches the open single-quote.
      reportError('should use triple-quotes', context, node, typeKind, 0);
      // If the open-quote is a single quote, the end-quote must
      // be too.  We report both for the benefit of auto-fixing.
      reportError('should use triple-quotes', context, node, typeKind, -1);
    } else {
      // offset == 0 matches the `#`.
      reportError('should use triple-quotes', context, node, typeKind, 0);
    }
  }

  if (!(0, _description_util.leadingQuotesOnTheirOwnLine)(descriptionWithQuotes)) {
    // Offset of 0 here matches the triple-quote location.
    reportError('should put the leading triple-quote on its own line', context, node, typeKind, 0);
  }

  if (!(0, _description_util.trailingQuotesOnTheirOwnLine)(descriptionWithQuotes)) {
    // Offset of -3 matches the triple-quote location.
    reportError('should put the trailing triple-quote on its own line', context, node, typeKind, -3);
  }
}

function TypesHaveDescriptions(configuration, context) {
  return {
    TypeExtensionDefinition: function TypeExtensionDefinition(node) {
      return false;
    },
    ScalarTypeDefinition: function ScalarTypeDefinition(node) {
      // We do not require docstrings for scalars because they
      // are not things we define; we're just making use of them.
      // validateTypeHasDescription(configuration, context, node, 'scalar');
    },
    ObjectTypeDefinition: function ObjectTypeDefinition(node) {
      validateTypeHasDescription(configuration, context, node, 'object');
    },
    InterfaceTypeDefinition: function InterfaceTypeDefinition(node) {
      validateTypeHasDescription(configuration, context, node, 'interface');
    },
    UnionTypeDefinition: function UnionTypeDefinition(node) {
      validateTypeHasDescription(configuration, context, node, 'union');
    },
    EnumTypeDefinition: function EnumTypeDefinition(node) {
      validateTypeHasDescription(configuration, context, node, 'enum');
    },
    InputObjectTypeDefinition: function InputObjectTypeDefinition(node) {
      validateTypeHasDescription(configuration, context, node, 'input object');
    }
  };
}