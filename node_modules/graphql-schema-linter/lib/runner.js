"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.run = run;

var _validator = require("./validator.js");

var _package = require("../package.json");

var _commander = require("commander");

var _configuration = require("./configuration.js");

var _schema = require("./schema.js");

var _options = require("./options.js");

var _figures = _interopRequireDefault(require("./figures"));

var _chalk = _interopRequireDefault(require("chalk"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function run(stdout, stdin, stderr, argv) {
  const commander = new _commander.Command().usage('[options] [schema.graphql ...]').option('-r, --rules <rules>', 'only the rules specified will be used to validate the schema. Example: fields-have-descriptions,types-have-descriptions').option('-f, --format <format>', 'choose the output format of the report. Possible values: json, text, compact').option('-s, --stdin', 'schema definition will be read from STDIN instead of specified file.').option('-c, --config-directory <path>', 'path to begin searching for config files.').option('-p, --custom-rule-paths <paths>', 'path to additional custom rules to be loaded. Example: rules/*.js').option('--comment-descriptions', 'use old way of defining descriptions in GraphQL SDL').option('--old-implements-syntax', 'use old way of defining implemented interfaces in GraphQL SDL') // DEPRECATED - This code should be removed in v1.0.0.
  .option('-o, --only <rules>', 'This option is DEPRECATED. Use `--rules` instead.') // DEPRECATED - This code should be removed in v1.0.0.
  .option('-e, --except <rules>', 'This option is DEPRECATED. Use `--rules` instead.').version(_package.version, '--version').parse(argv);

  if (commander.only || commander.except) {
    stderr.write(`${_chalk.default.yellow(_figures.default.warning)} The ${_chalk.default.bold('--only')} and ${_chalk.default.bold('--except')} command line options ` + `have been deprecated. They will be removed in ${_chalk.default.bold('v1.0.0')}.\n\n`);
  } // TODO Get configs from .graphqlconfig file


  const optionsFromCommandLine = getOptionsFromCommander(commander);
  const optionsFromConfig = (0, _options.loadOptionsFromConfigDir)(optionsFromCommandLine.configDirectory);
  const options = { ...optionsFromConfig,
    ...optionsFromCommandLine
  };
  const schema = await (0, _schema.loadSchema)(options, stdin);

  if (schema === null) {
    console.error('No valid schema input.');
    return 2;
  }

  const configuration = new _configuration.Configuration(schema, options);
  const issues = configuration.validate();
  issues.map(issue => {
    var prefix;

    if (issue.type == 'error') {
      prefix = `${_chalk.default.red(_figures.default.cross)} Error`;
    } else {
      prefix = `${_chalk.default.yellow(_figures.default.warning)} Warning`;
    }

    stderr.write(`${prefix} on ${_chalk.default.bold(issue.field)}: ${issue.message}\n\n`);
  });

  if (issues.some(issue => issue.type == 'error')) {
    return 2;
  }

  const formatter = configuration.getFormatter();
  const rules = configuration.getRules();
  const errors = (0, _validator.validateSchemaDefinition)(schema.definition, rules, configuration);
  const groupedErrors = groupErrorsBySchemaFilePath(errors, schema.sourceMap);
  stdout.write(formatter(groupedErrors));
  return errors.length > 0 ? 1 : 0;
}

function groupErrorsBySchemaFilePath(errors, schemaSourceMap) {
  return errors.reduce((groupedErrors, error) => {
    const path = schemaSourceMap.getOriginalPathForLine(error.locations[0].line);
    const offsetForPath = schemaSourceMap.getOffsetForPath(path);
    error.locations[0].line = error.locations[0].line - offsetForPath.startLine + 1;
    groupedErrors[path] = groupedErrors[path] || [];
    groupedErrors[path].push(error);
    return groupedErrors;
  }, {});
}

function getOptionsFromCommander(commander) {
  let options = {
    stdin: commander.stdin
  };

  if (commander.configDirectory) {
    options.configDirectory = commander.configDirectory;
  }

  if (commander.except) {
    options.except = commander.except.split(',');
  }

  if (commander.format) {
    options.format = commander.format;
  }

  if (commander.only) {
    options.only = commander.only.split(',');
  }

  if (commander.rules) {
    options.rules = commander.rules.split(',');
  }

  if (commander.customRulePaths) {
    options.customRulePaths = commander.customRulePaths.split(',');
  }

  if (commander.commentDescriptions) {
    options.commentDescriptions = commander.commentDescriptions;
  }

  if (commander.oldImplementsSyntax) {
    options.oldImplementsSyntax = commander.oldImplementsSyntax;
  }

  if (commander.args && commander.args.length) {
    options.schemaPaths = commander.args;
  }

  return options;
}