"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadSchema = loadSchema;
exports.emptySchema = exports.Schema = void 0;

var _fs = require("fs");

var _source_map = require("./source_map.js");

var _expandPaths = _interopRequireDefault(require("./util/expandPaths.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Schema {
  constructor(definition, sourceMap) {
    this.definition = definition;
    this.sourceMap = sourceMap;
  }

} // emptySchema is an empty schema for use in tests, when it's known that the
// schema won't be used. If any of the schema properties are accessed an error
// is thrown.


exports.Schema = Schema;
const emptySchema = {
  get definition() {
    throw Error('cannot get definition for empty schema');
  },

  get sourceMap() {
    throw Error('cannot get source map for empty schema');
  }

};
exports.emptySchema = emptySchema;

async function loadSchema(options, stdin) {
  /*
    options:
      - schemaPaths: [string array] file(s) to read schema from
      - stdin: [boolean] read the schema from stdin?
  */
  if (options.stdin && stdin) {
    return await loadSchemaFromStdin(stdin);
  } else if (options.schemaPaths) {
    return loadSchemaFromPaths(options.schemaPaths);
  }

  return null;
}

async function loadSchemaFromStdin(stdin) {
  const definition = await loadDefinitionFromStream(stdin);

  if (definition === null) {
    return null;
  }

  const sourceMap = new _source_map.SourceMap({
    stdin: definition
  });
  return new Schema(definition, sourceMap);
}

async function loadDefinitionFromStream(stream) {
  return new Promise((resolve, reject) => {
    let data = Buffer.alloc(0);
    stream.on('data', chunk => {
      data = Buffer.concat([data, chunk]);
    });
    stream.on('end', () => {
      // We must not convert data to a utf8 string util we have all of the
      // bytes. Chunks may not end on sequence boundaries.
      resolve(data.length > 0 ? data.toString('utf8') : null);
    });
  });
}

function loadSchemaFromPaths(paths) {
  const expandedPaths = (0, _expandPaths.default)(paths);
  const segments = getDefinitionSegmentsFromFiles(expandedPaths);

  if (Object.keys(segments).length === 0) {
    return null;
  }

  const sourceMap = new _source_map.SourceMap(segments);
  const definition = sourceMap.getCombinedSource();
  return new Schema(definition, sourceMap);
}

function getDefinitionFromFile(path) {
  try {
    return (0, _fs.readFileSync)(path).toString('utf8');
  } catch (e) {
    console.error(e.message);
  }

  return null;
}

function getDefinitionSegmentsFromFiles(paths) {
  return paths.reduce((segments, path) => {
    let definition = getDefinitionFromFile(path);

    if (definition) {
      segments[path] = definition;
    }

    return segments;
  }, {});
}